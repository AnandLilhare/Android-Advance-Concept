Interview Questions

Data Binding
1) Can I use findViewById() for all my Android Projects?
    Yes you can, you can build any Android Project using findViewById(). That's what we had been doing during the early days of  Android.

Using modern ways we can reduce the number of code lines, make code more readable, improve the performances and make code base more organised.



2) What is Kotlin Synthetic?
   Kotlin Synthetic(extensions) was a shorthand way used by developers to avoid findViewById() and directly call to the views using their ids. We added a Kotlin plugin for that in the app level gradle file. Since this method caused a lot of unexpected errors, Google deprecated it in 2021.



3) What is ViewBinding?
View Binding is a light weight version of Data binding. It only binds views to the code.

But data binding do both. Binding data  from code to views and binding views to the code. And data binding has a lot of other applications.

Once you learnt Data Binding, View Binding would be much easier to learn(nothing new at all).

Considering our project's requirements we should decide whether or not use Data Binding(or View Binding)

During later sections of this course, we will discuss about view binding and we will use view binding for our complete project examples.



4) What is Jetpack Compose?
With jetpack compose we do not need to use XML. We write all the codes to create views using Kotlin.

But, you need a very good(Advanced Level) Kotlin and Android development knowledge to use Jetpack Compose.

XML is much quicker to use(drag and drop, attributes window,..) and easier to learn/understand.

Jetpack compose has very high performance and lot of other advantages(Kotlin Multiplatform)

We can use both XML and Compose in the same project.

There are millions of Android Projects created using XML(which need continuous maintenance) . Only some developers use Compose for their new projects. So, as an Android Developer you need to master both XML way and Compose way.

I have added a lot of sections to this course to teach you jetpack compose fundamentals as well as practical applications. You will be able to master jetpack compose during later sections of this course.

View Model:
5. When is the ViewModel's onCleared() called?
A ViewModel's onCleared() is called when the ViewModel is no longer required.
It will be called when the app is put into the background and the app process is killed in order to free up the system's memory.
When the user invokes finish() of an activity, its view model will be cleared(). Also when we click on the back button,  ViewModel of current activity will be cleared (onCleared()  will be invoked)

Q.What is the difference between ViewModel() and AndroidViewModel() ?
The AndroidViewModel class extends ViewModel class, so it has all the same functionality.
The only added functionality for AndroidViewModel is that it is context aware, when initialising AndroidViewModel we have to pass the application context as a parameter.
AndroidViewModel is helpful if we require context to get a system service or have a similar requirement(displaying a Toast message).

class MyAnViewModel(application: Application) : AndroidViewModel(application) {
   ........
   ........
}

6) What is "ViewModelProvider" ?
We can not construct a ViewModel instance on our own. We need to use the ViewModelProvider utility provided by Android to create instances of ViewModels.

7) When do we need to create a ViewModelFactory class ?
ViewModelProvider can only instantiate ViewModels with no arg constructors.
So, if the ViewModel has constructor parameters(arguments) , ViewModelProvider need a little extra support to create instances of it.
We provide that extra support by creating a Factory class and passing its instance to the ViewModelProvider.

8) When we are extending AndroidViewModel, since it should always has "application" as a constructor parameter, do we need to use a ViewModelFactory ?
No, if the ViewModel created extending AndroidViewModel, does not have parameters other than "application", we do not need to use a ViewModelFactory for that.

9) What is the onCleared() function of a ViewModel?
  When a ViewModel object is no longer required, system will call to its onCleared() function to destroy(clear) it.
  It will be called when the app is put into the background and the app process is killed in order to free up the     
  system's memory.
 When the user invokes finish() of an activity, its view model will be cleared().
Also when we click on the back button, ViewModel of current activity will be cleared (onCleared() will be invoked)

Live Data
10) Where do we create/generate LiveData?
We usually define LiveData, inside ViewModel classes.
Also, supporting libraries like Room and Retrofit allows us to get data directly in LiveData format.

11)From where do we observe LiveData?
LiveData is a lifecycle-aware observable data holder class.
In android we have only 3 app components with lifecycles. Activities , fragments and services.
So, form activities, fragments and services we can observe LiveData.

12)What is the difference between RxJava and LiveData?
RxJava is not a lifecycle aware component.
So, data stream does not go off, when activity, fragment or service becomes inactive.
As a result of that, memory leaks or crashes can happen.
Therefore, we have to write codes to dispose them manually.
But, on the other hand, Android LiveData aware of lifecycle status changes.
And, they clean up themselves(stop emitting data) when their associated lifecycle is destroyed.

13)What is MutableLiveData, what is the difference between LiveData and MutableLiveData ?
MutableLiveData class is a subclass of LiveData class. In other words, MutableLiveData child class has created by extending the parent LiveData class.
A MutableLiveData instance can do everything a LiveData instnce can do and more.
Data in a LiveData object are only readable. We cannot update those values.
But, in the other hand, a Mutable LiveData object allows us to change(update) its values.
So, When we are creating our own live data(mostly in ViewModels), we define them as MutableLiveData.
But, when we are getting live data from other libraries such as Room and Retrofit we get them as LiveData.
We can easily transfer values between those two formats.



